= What is an Interceptor?
Michael Nygard
2017-06-26
:jbake-type: page
:toc: macro
:icons: font
:section: guides

toc::[]

_by {author}_, _{revdate}_

== Welcome

It doesn't take very long to bump into the word "Interceptor" when
you're working with Pedestal. They're the most important construct in
the library. Pretty much everything is an interceptor, including some
of the things that would normally be built in to a framework.

== What You Will Learn

After reading this guide, you will be able to :

- Explain the role of interceptors in Pedestal
- Compare interceptors to middleware
- Create interceptors that return asynchronously
- Create interceptors that affect execution of remaining interceptors
- Handle errors

== Guide Assumptions

This guide is for intermediate users who have worked through some
sample applications or the first few link:hello-world[Hello World]
guides. In particular, you should know how to run a build, start a
REPL, and start and stop your server.

You do not need to know any other Clojure web frameworks, but if you
do, you may find some of the comparisons useful. If not, that's OK,
just skip those sections.

== Getting Help if You're Stuck

If you get stuck at any point in this guide, please submit an
https://github.com/pedestal/docs/issues[issue] about this guide or hop
over to the
https://groups.google.com/forum/#!forum/pedestal-users[mailing list]
and raise your hand there. You can often find help in the #pedestal
channel of the https://clojurians.slack.com[Clojurians Slack team.]

== Where We Are Going

We're going to start with a fresh, empty project in this guide, with
just one interceptor. It will help illustrate the concepts we dive
into next. Then we look at the `IntoInterceptor` protocol to see how
we can create interceptors. After that, it's time to talk about the
execution model and see how we can make interceptors that change the
request-handling process dynamically.

We'll talk about the contract for an interceptor function and what it
can return. That leads us to asynchronous return.

Finally, we have to talk about error handling.

We'll wrap it all up by looking at a project created from the Pedestal
service template. We should be able to blow away the fog of mystery
and make the whole thing clear.

== Before We Begin

Make sure you have https://leiningen.org/[Leiningen] installed. We'll
be using it to run our project and to build a project from a template
later.

Feel free to consult the full source in
https://github.com/pedestal/docs/tree/master/content/guides[the
repository], but be warned that the file contains all the versions
that we built up through the previous guide. You'll need to navigate
some magic comments to pare it down to just the final version.

== A Place to Put Things

We need a project to contain our interceptors while we build them. For
now, let's make a project by hand so we understand each part. (In a
real project, you would probably use the Leiningen template to create
your new project.)

Make a directory for your project and drop this into `project.clj`:

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor/project.clj
----

This is as basic as it gets, but it's enough to run `lein repl` and
get to work. Go ahead and start a REPL.

Do take note of the two depedencies about logging. If you leave these
out, then you won't get any kind of logging, because slf4j will use
its "no-op" logger.

Make a file under `src/service.clj` with the following contents:

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor/src/service.clj
----
<1> We will fill in a route shortly
<2> Run on port 8820
<3> Give back our REPL thread after starting
<4> Use Jetty
<5> Use the routes from <1>
<6> Expand this "starter" service map into a ready-to-run map
<7> Run it

Load that into your REPL and run `start`. Be sure to bind the return
value from `start` to something so you can stop it later.

== Interceptor From Map

An interceptor is a value. That means it acts like any other value in
Clojure: you can pass it to a function or get it back as a return
value. You could put it in an atom, a ref, an agent, or pass it on a
channel.

The simplest way to create an interceptor is by just making a map. Any
map that has at least one key of `:enter`, `:leave`, or `:error` can
be used as an interceptor. Each of those keys should have a function
of one variable.

We'll create a really basic interceptor that responds to every HTTP
request with "Hello, world!".

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor/src/service.clj[tags=hello]
----

There are a couple of things to point out here. First, this is
defining a var in the namespace and binding it to the value in the
map. That means the map is evaluated at compile time.

Second, the map has a `:name` key. That's not one of the required
keys, but if it exists, Pedestal will print it in some debug messages
and logs. It can help you narrow down a problem later.

The `:enter` key is where things get a little more interesting. (A
little, but not much. It's just a hello world after all.) Note that it
has a function that assocs a value onto the context under the
`:response` key. That value happens to be shaped in a way that the
link:../reference/servlet-interceptor[Servlet Interceptor] looks for.

This is where we have to start being precise about the difference
between an interceptor how it gets invoked. "Interceptor" is a very
general concept. It can be used in a lot of different ways, not just
for HTTP handling in a web framework. In fact, HTTP handling comes
from the link:../api/pedestal.service/index.html[pedestal.service]
module. Interceptor invocation and handling comes from
link:../api/pedestal.interceptor/index.html[pedestal.interceptor]
which doesn't depend at all on pedestal.service.

For example, we have a project that lets you invoke a chain of
interceptors when a message arrives on a Kafka topic. You could invoke
interceptors to do batch processing. They are an implementation of the
general "pipes and filters" architecture pattern.

=== Enter

The `:enter` function is called on the "way in" to a bunch of
interceptors. If you look at a route with a collection of
interceptors, they'll have their `:enter` functions invoked from
left-to-right. Each on receives the new value of the context returned
by the previous one.

=== Leave

The `:leave` function is called on the "way out" of a bunch of
interceptors. That same collection of interceptors on a route will be
called from right-to-left. Like the enter functions, each leave
function receives the context and returns a (possibly modified)
context.

=== Error

The `:error` functions are a bit special. If an interceptor throws an
exception, then Pedestal starts looking for an interceptor with an
`:error` function. This goes from right-to-left like the "leave"
functions. The main difference is that an error-handling interceptor
may indicate that the error is totally resolved and Pedestal will
resume looking for `:leave` functions. See link:error-handling[Error
Handling] below for all the gory details.

== The Queue and the Stack

To be continued...

== The Path So Far

== Where To Next?
